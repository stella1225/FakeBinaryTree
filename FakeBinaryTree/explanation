大まかな方針は、今いる頂点番号とその頂点にたどり着く方法を記録することで解けます。

右の子、または左の子へ移動する方法は一通りに定まります。
ですが、親の時は移動先が1つの場合と2つの場合があります。
どのように親の頂点の個数を判定すればよいでしょうか？

頂点1が属している列を高さ1、2と3が属している列を高さ2・・・とよぶことにします。
今いる頂点番号vとし、次は親に移動する状況を考えます。
vが高さnの右端と左端にいる場合は親の数は1、それ以外の場合は親の数が2つになります。
なので、そのことを判定すればよいです。

右端の頂点番号を列挙してみましょう。
1,3,6,10...
これは、初項2、公差1の等差数列の階差数列になっています。
したがって、高さnの右端の頂点番号は、
1+(1からn-1番目の初項2、公差1の等差数列の和)=n*(n+1)/2と
求めることができます。
左端の頂点番号は、高さn-1の右端の頂点番号+1で求めることができます。

以上を実装したものが関数pwd()になります。
右端の頂点番号と左端の頂点番号が格納されている
vectorなどを用意するのも一つの方法ですが、
ここでは、右端の頂点番号を0番目として、右端から何番目であるかを求めることによって判定しています。
右端からの頂点番号をdiffとすると、
diffが0ならば、右端にあるとわかり、親の数は一つ。
左端については、高さnの頂点数はnです。
したがって、diffがn-1であれば、左端にあるといえます。

今いる頂点番号と、そこに着くまでの方法の数は、mapでもっています。
queueには、次に探索する頂点番号が格納されています。
setを用意するのは、queueに重複した頂点番号が格納されないようにするためです。

計算量は、
文字列の最大サイズ1e2(==N)、一度の探索で最大、
高さの最大回2e4(==M)、
setからqueueに移す過程で2e4*log(2e4)、
頂点vの高さを求めるのにlog(2e4)
なので、O(NM^2logM)になり、解けました。

(でもN==1000のケースでも59msとかでできてるんですよね、なんっでしょう・・・・)？？？